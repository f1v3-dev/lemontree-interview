# 요구사항 분석

## 핵심 요구사항

- 거래를 진행할 때 오류가 발생하지 않는 것이 가장 중요하다.
- 하지만, 오류가 발생하더라도 어느 시점에서 발생했는지 파악할 수 있어야 한다.

### 유저

> MySQL에서는 `user`라는 키워드가 존재하기 때문에 `member`로 대체합니다.

- 현재 보유 금액
- 상태 (가입 / 탈퇴)
- 보유 가능한 최대 한도가 존재 (유저마다 다름)
- 1회/1일/1달 결제 한도가 존재

### 결제

- 어떤 상황에서든 결제는 1건당 1회가 일어나야 합니다.
- 결제 실패시 어느 시점에서 실패했는지 파악할 수 있어야 합니다.

- 머니 결제 API 요청시 발생할 수 있는 예외
  1. 잔액 부족
  2. 1회 결제 한도 초과
  3. 1일 결제 한도 초과
  4. 1달 결제 한도 초과


#### 나의 생각

- 격리 수준을 설정하여 동시에 여러 건의 결제가 일어나지 않도록 설정할 수 있나?
    - DB 격리 수준 중 어느 격리 수준이 적합할까
    - 가장 높은 격리 수준인 `SERIALIZABLE`을 사용했을 때의 **trade-off** 는 무엇일까?
- 결제라는 비즈니스 로직을 수행하면서 각각의 예외 상황을 어떻게 처리해야할까?
- @Transactional 어노테이션을 사용해서 격리 수준을 설정한다면?


- 1회 결제 한도 초과
  - 유저의 1회 결제 한도와 비교하여 초과했는지 확인

- 1일/1달 결제 한도
  - 유저의 누적 결제 금액을 만들어두고 비교하여 초과했는지 확인
  - 누적 금액은 @Scheduled 어노테이션을 사용하여 매일/매달 초기화
  - 이 방식의 문제점은? - 초기화를 진행할 때 결제를 막아야 함.

#### 결정 사항

- 결제/페이백 시스템은 `동시성 제어`가 가장 핵심적으로 판단.
- `REPEATABLE READ` 격리 수준을 사용
- `비관적 락(Pessimistic Lock)`을 사용하여 동시성 제어

_발생할 수 있는 문제_

- 비관적 락과 높은 격리 수준을 사용하다보니 `Deadlock`이 발생할 수 있음
- 이에 대한 해결책이 필요해보임.

---

## 개발 환경

#### Connection Pool

> DBCP2 vs HikariCP

- DBCP2
  - 오랫동안 사용되어 안정적인 라이브러리인 점
  - 여러가지 설정을 할 수 있어 다양한 기능을 커스터마이징 할 수 있음.
  - 하지만, 설정이 복잡하며 성능이 떨어진다는 단점이 존재

- HikariCP
  - 설정이 간단하고, 성능이 뛰어나다고 알려져 있음. (대규모 트랜잭션을 처리할 때 유리할 것이라고 예상)
  - 하지만, 최신 라이브러리이기 때문에 DBCP2에 비해 안정성이 떨어질 수 있으며, 다양한 설정을 할 수 없다는 단점이 존재

많은 사용자들이 이용할 경우에 대비하여, 성능적으로 유리한 HikariCP를 사용하는 것이 유리하다고 판단하였습니다.

```properties
# hikariCP Connection Pool
spring.datasource.hikari.connection-timeout=5000
spring.datasource.hikari.validation-timeout=5000
spring.datasource.hikari.idle-timeout=60000
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.minimum-idle=10
spring.datasource.hikari.maximum-pool-size=10
```

#### DB Engine

> InnoDB vs MyISAM

- InnoDB
  - 트랜잭션을 지원
  - 우수한 성능 (다수 동시접속 및 대용량 처리)
  - 장애 복구 기능
- MyISAM
  - 읽기 위주의 작업만 필요한 경우 유리 (조회 및 검색)
  - 트랜잭션이나 복구 기능이 필요 없는 경우 주로 사용
  - 한 번에 대량의 데이터를 입력하는 배치성 테이블 

중요 데이터를 다루는 결제 시스템에서는 트랜잭션 및 대용량 처리, 장애 복구 등의 기능을 제공하는 InnoDB를 사용하는 것이 유리하다고 판단하였습니다.

### @Transactional

![img.png](img/timeout.png)
- 거래 실행은 5초의 제한 시간이 주어진다.

![img.png](img/timeout2.png)
시간이 경과하였을 경우 TransactionException 발생!

![img.png](img/isolation.png)
- 동일한 결제/취소가 중복해서 일어날 수 있다.

## Scheduler 
![img_1.png](img/daily_scheduler.png)
12시에 dailyAccumulate 초기화

```json
{
  "memberId": 1,
  "name": "정승조",
  "balance": 94000,
  "onceLimit": 5000,
  "dailyLimit": 10000,
  "monthlyLimit": 15000,
  "dailyAccumulate": 0,
  "monthlyAccumulate": 6000,
  "isDeleted": false
}
```

## ISOLATION - SERIALIZABLE

![img_2.png](img/isolation2.png)

- 동시에 여러 건의 결제가 발생했을 경우, Deadlock found when trying to get lock; try restarting transaction 에러 발생